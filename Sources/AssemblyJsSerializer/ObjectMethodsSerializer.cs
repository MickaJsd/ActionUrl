using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;

namespace AssemblyJsSerializer
{
    public class ObjectMethodsSerializer
    {
        public ObjectMethodsSerializer(Assembly sourceAssembly)
        {
            this.SourceAssembly = sourceAssembly;
            this.FieldFormat = DEFAULT_FIELD_FORMAT;
            this.FieldContentGenerator = DefaultFieldContentGenerator;
            this.ObjectName = this.SourceAssembly.GetName().Name;
        }
        public virtual string GetTypeName(Type t) => t.Name;
        public virtual string GetMethodName(MethodInfo m) => m.Name;
        public virtual Func<Type, bool> TypeFilter => (t) => true;
        public virtual Func<MethodInfo, bool> MethodFilter => (m) => true;

        public string FieldFormat
        {
            get; set;
        }
        public Func<Type, MethodInfo, string> FieldContentGenerator
        {
            get; set;
        }
        public string ObjectName
        {
            get; set;
        }


        public Func<Type, MethodInfo, string> DefaultFieldContentGenerator => (t, m) => string.Format(FieldFormat, this.GetTypeName(t), this.GetMethodName(m));

        private const string CAUTION_HEADER =
@"//------------------------------------------------------------------------------
// <auto-generated>
//    This code was generated.
//
//    Manual changes to this file may cause unexpected behavior in your application.  
//    Manual changes to this file will be overwritten if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
";
        private const string DEFAULT_FIELD_FORMAT = "'{0}.{1}'";
        private const string START_OBJECT = "{\r\n";
        private const char END_OBJECT = '}';
        private StringBuilder StartNewGlobaleObjectBuilder() => new StringBuilder($"{CAUTION_HEADER}\r\nconst {this.ObjectName} = {START_OBJECT}");
        private StringBuilder StartNewObjectBuilder() => new StringBuilder(START_OBJECT);
        private string EndObjectToString(StringBuilder sb, int indentlevel) => sb.Append($"{Indent(indentlevel)}{END_OBJECT}").ToString();
        private void AppendNewField(StringBuilder sb, string fieldName, string content, int indentlevel) => sb.Append($"{Indent(indentlevel)}{SerializeFieldName(fieldName)}:{content},\r\n");
        private string SerializeFieldName(string name) => $"'{name}'";
        private string Indent(int number)
        {
            return string.Empty.PadLeft(number*4, ' ');
        }

        private Assembly SourceAssembly
        {
            get; set;
        }

        private IEnumerable<Type> ReadTypes()
        {
            foreach (Type type in this.SourceAssembly.GetTypes().Where(TypeFilter))
            {
                yield return type;
            }
        }

        private IEnumerable<MethodInfo> ReadMethods(Type type)
        {
            foreach (MethodInfo method in type.GetMethods().Where(MethodFilter))
            {
                yield return method;
            }
        }

        public string Serialize()
        {
            StringBuilder sbGlobalObject = StartNewGlobaleObjectBuilder();
            foreach (Type type in this.ReadTypes())
            {
                StringBuilder sbType = StartNewObjectBuilder();
                bool hasActions = false;

                foreach (MethodInfo method in this.ReadMethods(type))
                {
                    hasActions = true;
                    AppendNewField(sbType, this.GetMethodName(method), FieldContentGenerator(type, method),2);
                }

                if (hasActions)
                {
                    AppendNewField(sbGlobalObject, this.GetTypeName(type), EndObjectToString(sbType,1),1);
                }
            }

            return EndObjectToString(sbGlobalObject, 0);
        }

        public string SerializeToFile(string filePath)
        {
            var fileInfo = new FileInfo(filePath);
            fileInfo.Directory.Create();
            string generatedContent = this.Serialize();
            File.WriteAllText(filePath, generatedContent);
            return generatedContent;
        }
    }
}
